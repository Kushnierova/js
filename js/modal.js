
// 1
// Change code below this line
// function sayHi() {
//   console.log("Hello, this is my first function!")
//   }
//   sayHi();

// 2

// function add(a,b,c) {
//   console.log (`Addition result equals ${a + b + c}`);
//   // Change code above this line
// }

// add(15, 27, 10);
// add(10, 20, 30);
// add(5, 10, 15);

// 3

// function add(a, b, c) {
//   // Change code below this line
//  return a + b + c;


//   // Change code above this line
// }

// add(2, 5, 8); // 15

// console.log(add(15, 27, 10));
// console.log(add(10, 20, 30));
// console.log(add(5, 10, 15));

// function makeMessage (name, price) {
//   // Change code below this line
//    const message = `You picked ${name} , price per item is ${price} credits`;
//   // Change code above this line
//   console.log(message)
//   return message;
// };
// makeMessage('Radar', 6150);
// makeMessage('Scanner', 3500);
// makeMessage('Reactor', 8000);
// makeMessage('Engine', 4070);

// function makeOrderMessage(orderedQuantity, pricePerDroid, deliveryFee) {
//   // Change code below this line
//   const totalPrice = orderedQuantity * pricePerItem;
//    const message = `You ordered droids worth ${totalPrice} credits. Delivery ${deliveryFee} is included in total price.`;
//   console.log(message)
//   // Change code above this line
//   return message;
// }
// makeOrderMessage(2, 100, 50);
// makeOrderMessage(4, 300, 100);
// makeOrderMessage(10, 70, 200)

// function isValidPassword(password) {
//   const SAVED_PASSWORD = 'jqueryismyjam';
//   // Change code below this line
//   const isMatch = 'isValidPassword';

//   // Change code above this line
//   console.log( SAVED_PASSWORD === isMatch);
//   return isMatch;
// }
// isValidPassword('mangodab3st');
// isValidPassword('kiwirul3z');
// isValidPassword('jqueryismyjam');

// const number1 = Number(prompt("Enter a number 1, please"));
// console.log(number1);
// const number2 = Number(prompt("Enter a number 2, please"));
// console.log(number2);

// if (number1 > number2) {
//     console.log(">");
//   } else if (number1 === number2) {
//     console.log("=");
//   } else if (number1 < number2) {
//     console.log("<");
//   }
//======================================= Знайомство з JavaScript
// Коли ми говоримо про програмування, перше, що спадає на думку - це набір інструкцій у файлі. Вихідний код (source code) - це текст комп'ютерної програми будь-якою мовою програмування, набір легких для читання синтаксичних конструкцій, що описують набір інструкцій для комп'ютера.

// Власне сам вихідний код незрозумілий для машини. Існує крок, що виконується після написання програми, який конвертує вихідний код у файлі в набір інструкцій, зрозумілих комп'ютеру. Цим займається спеціальна програма: компілятор або інтерпретатор. З цього можна зробити висновок - код пишеться не для машин, а для розробника. Вихідний код повинен не лише правильно вирішувати задачу, але й бути зрозумілим.

//========================================== Логічне мислення
// В світі існує багато мов програмування. Вони не такі складні, як людські, тому що складаються з досить маленького набору синтаксичних конструкцій, а їх принципи роботи та базові концепції схожі між різними мовами.

// Досвідчені розробники розглядають проблеми з точки зору алгоритмів - набору кроків, які потрібно виконати для досягнення певної мети. Ми постійно використовуємо алгоритми у повсякденному житті. Наприклад, процес приготування чаю - це набір необхідних кроків (алгоритм) для досягнення результату. Коли ви звикнете вибудовувати рішення задачі у вигляді алгоритму, мова програмування буде всього лиш інструментом.

// JavaScript
// JavaScript - реалізація специфікації EcmaScript, високорівнева мова програмування, яка підтримується усіма сучасними веб-браузерами. В першу чергу призначена для взаємодії з елементами веб-сторінок і додавання інтерактивності.

// ЦІКАВО
// JavaScript жодним чином не стосується мови Java. Це дві незалежні мови програмування.

// У Front-end розробці, JavaScript використовується разом із HTML і CSS для забезпечення функціональності веб-сторінки, а саме:

// нескладні обчислення
// перевірка і маніпуляція даними, введеними користувачем
// зберігання інформації в браузері користувача
// динамічна зміна HTML-документа
// реакція на дії користувача
// створення інтерактивних елементів: галерей, графіків і т. п.
// взаємодія з бекендом
// ЦІКАВО
// Якщо JavaScript-код пишеться для виконання в браузері (Front-end), у розробника відсутні інструменти і доступ до файлової або операційної системи з міркувань безпеки.

// На сьогодні, використовуючи JavaScript, можна створювати:

// веб-застосунки на фреймворках React, Vue, Angular та інших
// бекенд-застосунки на Node.js
// мобільні застосунки на React Native або Ionic
// десктоп-застосунки за допомогою Electron
// мікроконтролери з Johnny-Five і Espruino
// Для реалізації всіх цих можливостей, необхідно добре знати синтаксис мови, її особливості та механізми, тренуватися мислити алгоритмічно і вирішувати якомога більше практичних задач.

// ==================================Підключення скрипту
// Щоб додати скрипт на веб-сторінку, в HTML-файлі використовується тег script, в атрибуті src якого, зазначаємо посилання на зовнішній JavaScript-файл.

// Щоб підключити JavaScript із зовнішнього файлу:

// Створіть файл з розширенням .js і помістіть його у підпапку js.
// Потім вкажіть шлях до файлу скрипту в атрибуті src тегу script.
// <!DOCTYPE html>
// <html lang="en">
//   <head>
//     <meta charset="UTF-8" />
//     <title>JavaScript is fun!</title>
//   </head>

//   <body>
//     <!-- контент -->
//     <script src="js/script.js"></script>
//   </body>
// </html>

// ЦІКАВО
// Розміщення JavaScript файлу в папці js не вимагається, однак, - це хороша практика.

// Якщо скрипт підключений в <head>, рендеринг сторінки зупиняється доти, доки скрипт не завантажиться і повністю виконається. Браузер завантажує і відображає HTML поступово. Якщо він бачить тег <script>, без додаткових атрибутів, то спочатку виконується скрипт, і тільки потім обробляється інший код HTML-файлу. Тому, скрипт підключають перед закриваючим тегом <body>, після всього вмісту, як у прикладі.

// Декілька скриптів
// Підключаючи декілька JavaScript-файлів до сторінки, інтерпретатор обробляє їх у тому порядку,
//  в якому вони зазначені в HTML-файлі.

/* {<script src="js/script-1.js"></script>
<script src="js/script-2.js"></script>} */
// ==========================Інструменти розробника
// При написанні коду завжди будуть сповіщення і помилки, - це нормально. Консоль браузера показує інформацію, пов'язану із веб-сторінкою, зокрема повідомлення про помилки і попередження виконання JS-коду, запущеного в контексті сторінки.

// Наступні комбінації клавіш відкривають інструменти розробника на вкладці Console:

// Windows і Linux - Ctrl + Shift + J або F12
// MacOS - Command + Option + J
// Додаткові матеріали
// Виведення повідомлень в консоль
// Довідник з API консолі
// =====================================Основи синтаксису
// При написанні коду важливо не просто знати, який символ або конструкцію можна використовувати, але насамперед необхідно розуміти термінологію і складові вихідного коду. В цій секції нам не важливе розуміння як що працює, ми тільки познайомимось з базовою термінологією і синтаксисом.

// ===========================================Інструкція
// Інструкція (statement) - це пов'язаний набір слів і символів із синтаксису мови, які об'єднуються з метою вираження однієї ідеї, однієї інструкції для машини.

// a = b * 2;

// Інструкції в JavaScript завершуються крапкою з комою, яку можна порівняти із крапкою наприкінці речення вашої рідної мови.

// a і b - змінні (як в алгебраїчному рівнянні), це сховища даних, які використовує програма. Змінна складається із ідентифікатора (імені) і пов'язаного з ним значення.
// 2 - просто число. Це називається значенням літерала (literal value), тому що не зберігається у змінній.
// = і * - оператори, вчиняють дії над значеннями і змінними.
// Уявімо, що змінна b вже зберігає число 10. Тоді ця інструкція каже машині:

// Піди знайди змінну з ідентифікатором b і запитай, яке в неї зараз значення.
// Підстав значення змінної b (10), у твердження на місце b.
// Виконай операцію множення 10 на 2.
// Запиши результат обчислення виразу правої частини у змінну a.
// ЦІКАВО
// Завершення інструкції крапкою з комою не вимагається, однак, настійно рекомендується завжди її ставити. Це просте правило зробить код зрозумілішим і допоможе уникнути неочевидних помилок.

// =================================================Вираз
// Інструкції складаються із частин, як і в будь-якій мові речення складаються із фраз і ці фрази називаються виразами.

// Вираз (expression) - посилання на змінну або значення, або на набір змінних і значень в поєднанні з операторами.

// [ [a] = [ [b] * [2] ] ]

// Інструкція з прикладу вище містить 5 виразів, які виділені квадратними дужками для візуалізації (це не синтаксис мови):

// [2] - вираз значення літерала.
// [b]і[a] - вирази змінної, означають необхідність підставити значення змінної, але лише у тому випадку, якщо змінна складається із правої частини виразу присвоювання.
// [b * 2] - арифметичний вираз множення.
// [a = b * 2] - вираз присвоювання. У нашому випадку вказує на необхідність обчислення правої частини виразу і присвоювання результату змінної a у лівій частині виразу.
// Також існує вираз виклику, порівняння тощо. Ми не будемо зараз розглядати їх усіх, нам важливо розуміти, з яких частин складається вихідний код і як правильно його читати.

// ===========================================Інтерфейс
// Коли ми підходимо до автомату з кавою або сідаємо за кермо автомобіля, існує певний набір елементів управління, з яким можна взаємодіяти. У програмуванні це називається інтерфейс.

// Інтерфейс - це набір властивостей і методів сутності, доступних для використання у вихідному коді.

//=============================================== Властивість
// У нас з вами є властивості: зріст, вага, колір очей, тобто якісь описові характеристики. Так само і у даних є властивості, наприклад у рядка є властивість його довжини. Синтаксис звернення до властивості дуже простий - через крапку.

// сутність.ім`я_властивості

// Для наочності, звернемось до властивості рядка length, яка містить кіл-ть символів рядка.

// "JavaScript is awesome".length;

// ==================================================Метод
// Це виклик дії, наприклад присісти або плавати, тобто якась активна операція. Так само і у даних є свої заздалегідь визначені методи, наприклад, можна додати або видалити елементи з колекції, перевести рядок в інший регістр тощо. Синтаксис виклику метода дуже схожий на звернення до властивості, але в кінці додається пара круглих дужок.

// сутність.ім`я_метода()

// Для прикладу звернемось до методу рядка toUpperCase(), який зробить усі літери великими.

// "JavaScript is awesome".toUpperCase();

// ===============================================Суворий режим
// Нова можливість у специфікації ECMAScript 5, яка дозволяє переводити скрипт у режим повної відповідності сучасному стандарту. Це запобігає певним помилкам, як-от використання небезпечних і застарілих конструкцій.

// Для того, щоб перевести скрипт в суворий режим, достатньо зазначити директиву на початку js-файлу. Завжди пишіть код в суворому режимі.

// script.js
// "use strict";
// Це коментар. Далі йде увесь код JS-файлу
// Змінні і типи
// Змінні використовуються для зберігання даних і складаються із ідентифікатора (імені) і області в пам'яті, де зберігається їх значення. Змінну можна уявити у вигляді коробки з назвою, в якій щось лежить (значення).

// <ключове_слово> <ім`я_змінної> = <значення>

// Імена змінних
// Ідентифікатор - це ім'я змінної, функції або класу. Складається з одного або декількох символів у наступному форматі.

// Першим символом повинна бути літера a-z або A-Z, символ підкреслення _ або знак долара $.
// Інші символи можуть бути літерами a-z, A-Z, цифрами 0-9, підкресленнями _ і знаками долара $.
// Ідентифікатори чуттєві до регістру. Це означає, що змінні user, usEr і User - різні.
// Ім'я змінної повинно бути зрозумілим.

// # ❌ Погано
// chislo
// korzina_tovarov
// profil_polzovatelya
// tekushiy_mesyaz

// # ✅ Добре
// number
// cart
// userProfile
// currentMonth

// Використання camelCase-нотації для ідентифікаторів - це стандарт. Перше слово пишеться малими літерами, а кожне наступне починається з великої. Наприклад, user, greetUser, getUserData, isActive, activeGuestCount, totalWorkerSalary.

// Як називати змінні
// Домовленість про імена змінних
// Ключові слова
// Існує список зарезервованих ключових слів, які мають спеціальне значення і використовуються для певних конструкцій. Забороняється використовувати ключові слова у якості ідентифікаторів.

// abstract	arguments	await	boolean
// break	byte	case	catch
// char	class	const	continue
// debugger	default	delete	do
// double	else	enum	eval
// export	extends	false	final
// finally	float	for	function
// goto	if	implements	import
// in	instanceof	int	interface
// let	long	native	new
// null	package	private	protected
// public	return	short	static
// super	switch	synchronized	this
// throw	throws	transient	true
// try	typeof	var	void
// volatile	while	with	yield
// Оголошення змінних
// Оголошення змінної починається з ключового слова const. Така змінна повинна бути одразу ініціалізована значенням, після чого її не можна перевизначити.

// // Змінні, оголошені як const, обов'язково повинні бути ініціалізовані
// // значенням під час оголошення, інакше виникне помилка.
// const yearOfBirth = 2006;
// console.log(yearOfBirth); // 2006

// // Якщо зміна оголошена як const, перезаписати її значення не можна.
// // При спробі присвоїти нове значення, виникне помилка виконання скрипту.
// yearOfBirth = 2020; // ❌ Неправильно, виникне помилка


// Для того, щоб оголосити змінну, якій у подальшому можна буде присвоїти нове значення, використовується ключове слово let.

// // Змінним, оголошеним через let, не обов'язково одразу присвоювати значення.
// let age;

// // Якщо змінній, оголошеній як let, не було присвоєно значення,
// // вона ініціалізується спеціальним значенням undefined (не визначено).
// console.log(age); // undefined

// // console.log() - це метод для виведення даних у консоль браузера,
// // пізніше познайомимось з ним детальніше.

// // Якщо змінна оголошена як let, її значення можна перезаписати.
// age = 14;
// console.log(age); // 14


// ЦІКАВО
// Оголошення змінної без ключового слова let або const призведе до помилки, якщо скрипт виконується в суворому режимі.

// Коли використовувати const і let
// Єдина відмінність const і let полягає у тому, що const забороняє повторно присвоювати змінній будь-яке значення. Оголошення const робить код читабельнішим, тому що змінна завжди посилається на одне і те саме зачення. У випадку з let такої впевненості немає.

// Буде розумно використовувати let і const наступним чином:

// Використовуйте const за замовчуванням, більшість змінних будуть оголошені саме таким чином.
// Використовуйте let, якщо необхідно присвоїти змінній інше значення під час виконання скрипту.
// константи і КОНСТАНТИ
// Імена КОНСТАНТ - змінних, значення яких не змінюється ніколи впродовж роботи всього скрипту, як правило, записуються у форматі UPPER_SNAKE_CASE.

// // Константа, що зберігає значення кольору
// const COLOR_TEAL = "#009688";

// // Константа, що зберігає повідомлення про результат логіну
// const LOGIN_SUCCESS_MESSAGE = "Ласкаво просимо!";

// Абсолютна більшість змінних – константи в іншому сенсі, вони просто не змінюють значення після присвоєння. Але, у різних запусках скрипту, це значення може бути різним. Імена таких змінних записують за допомогою формату camelCase.

// Звернення до змінної
// Важливо розрізняти невизначені і неоголошені змінні.

// Невизначена (undefined) - це змінна, яка була оголошена ключовим словом let, але не ініціалізована значенням. За замовчуванням їй присвоюється початкове значення undefined.

// let username;
// console.log(username); // undefined

// Неоголошена (undeclared або not defined) - це змінна, яка не була оголошена в доступній області видимості. Спроба звернутися до змінної до її оголошення призведе до помилки. Наприклад, щоб прочитати або змінити її значення.

// // ❌ Неправильно, буде помилка
// age = 15; // ReferenceError: Cannot access 'age' before initialization
// console.log(age); // ReferenceError: age is not defined

// // Оголошення змінної age
// let age = 20;

// // ✅ Правильно, звертаємось після оголошення
// age = 25;
// console.log(age); // 25


// Примітивні типи
// В JavaScript змінна не асоціюється з будь-яким типом даних, тип має її значення. Тобто змінна може зберігати значення різних типів.

// Number - цілі числа і числа з плаваючою комою (крапкою).

// const age = 20;
// const points = 15.8;

// String - рядки, послідовність з нуля або більше символів. Рядок починається і закінчується одинарними ', або подвійними лапками ".

// const username = "Mango";
// const description = "JavaSript для початківців";

// Boolean - логічний тип даних, прапорці стану. Всього два значення: true і false. Наприклад, на запитання чи увімкнено світло в кімнаті, можна відповісти так (true) або ні (false).

// true — так, вірно, істина, 1
// false — ні, невірно, неправда, 0
// Зверніть увагу на імена змінних, що містять буль. Вони ставлять запитання, і відповідь на нього - так або ні.

// const isLoggedIn = true;
// const canMerge = false;
// const hasChildren = true;
// const isModalOpen = false;

// null - особливе значення, яке по суті означає ніщо. Використовується в тих ситуаціях, коли необхідно явно вказати порожнечу. Наприклад, якщо користувач нічого не вибрав, то можна сказати що значення null.

// let selectedProduct = null;

// undefined - ще одне спеціальне значення. За замовчуванням, коли змінна оголошується, але не ініціалізується, її значення не визначено, їй присвоюється undefined.

// let username;
// console.log(username); // undefined

// Оператор typeof
// Використовується для отримання типу значення змінної. Повертає на місце свого виклику тип значення змінної, вказаного після нього - рядок, в якому вказано тип.

// let username;
// console.log(typeof username); // "undefined"

// let inputValue = null;
// console.log(typeof inputValue); // "object"

// const quantity = 17;
// console.log(typeof quantity); // "number"

// const message = "JavaScript is awesome!";
// console.log(typeof message); // "string"

// const isSidebarOpen = false;
// console.log(typeof isSidebarOpen); // "boolean"

// Метод concat()
// Об'єднує два або більше масивів в один. Він не змінює масив,
//  на якому викликається, а повертає новий. Порядок аргументів методу впливає на порядок елементів нового масиву.

// const oldClients = ["Mango", "Ajax", "Poly", "Kiwi"];
// const newClients = ["Monkong", "Singu"];

// const allClientsWithOldFirst = oldClients.concat(newClients);
// console.log(allClientsWithOldFirst); // ["Mango", "Ajax", "Poly", "Kiwi", "Monkong", "Singu"]

// const allClientsWithNewFirst = newClients.concat(oldClients);
// console.log(allClientsWithNewFirst); // ["Monkong", "Singu", "Mango", "Ajax", "Poly", "Kiwi"]

// console.log(oldClients); // ["Mango", "Ajax", "Poly", "Kiwi"]
// console.log(newClients); // ["Monkong", "Singu"]

// const a=[1,2,3];
// const b=[5,6,7];
// const c=4;
// const arr =a.concat(c,b) 
// console.log(arr) //[1, 2, 3, 4, 5, 6, 7]


//                                                                         Метод splice()
// Швейцарський ніж для роботи з масивами, якщо вихідний масив необхідно змінити. Видаляє, додає і замінює елементи у довільному місці масиву.

//                                                                                 Видалення
// Щоб видалити елементи в масиві, передаються два аргументи.

// splice(position, num)

// position - вказує на позицію (індекс) першого елемента для видалення
// num - визначає кількість елементів, що видаляються
// Метод splice змінює вихідний масив і повертає масив, що містить видалені елементи. Наприклад, у нас є масив оцінок, який містить п'ять чисел від 1 до 5.

// const scores = [1, 2, 3, 4, 5];

// Видаляємо три елементи масиву, починаючи з першого елемента (індекс 0)
// const deletedScores = scores.splice(0, 3);

// Тепер масив scores містить два елементи
// console.log(scores); // [4, 5]

// А масив deletedScores містить три видалені елементи
// console.log(deletedScores); // [1, 2, 3]

// На зображенні показаний виклик методу score.splice (0, 3) з прикладу.

// splice remove
// ЦІКАВО
// На практиці, значення, що повертається (масив видалених елементів), використовується рідко. Переважно, просто необхідно видалити елементи з масиву.



// const numbers2 = [1, 2, 3, 4, 5, 5, 5, 6, 7, 8, 9]
// const numbers3  = numbers2.splice(5, 2)
// // console.log(numbers2)
// console.log(numbers3)




//                                                          Додавання
// Для того, щоб додати один або декілька елементів в масив, необхідно передати три або більше аргументи, за такої умови, другий аргумент повинен дорівнювати нулю.

// splice(position, 0, new_element_1, new_element_2, ...)

// Аргумент position вказує початкову позицію в масиві, куди будуть вставлені нові елементи.
// Другий аргумент - це нуль, він говорить методу не видаляти елементи в місці додавання нових.
// Третій, четвертий і всі наступні аргументи - це нові елементи, які додаються в масив.
// Наприклад, у нас є масив з назвами кольорів у вигляді рядків. Додамо новий колір перед елементом з індексом 2.

// const colors = ["red", "green", "blue"];

// colors.splice(2, 0, "purple");
// console.log(colors); // ["red", "green", "purple", "blue"]

// На малюнку показаний виклик методу colors.splice(2, 0, 'purple') з прикладу.

// splice insert
// Можна додати довільну кількість елементів, передавши четвертий, п'ятий аргумент тощо.

// const colors = ["red", "green", "blue"];

// colors.splice(1, 0, "yellow", "pink");
// console.log(colors); // ["red", "yellow", "pink", "green", "blue"]


// const numbers2 = [1, 2, 3, 4, 5, 5, 5, 6, 7, 8, 9]
// const copy = numbers2.slice()
// const deleted = copy.splice(5, 2)
// console.log(copy)
// console.log(deleted) //[5,5]
// console.log(numbers2)

// const numbers3 = [1, 2, 3, 6, 7, 8, 9]
// const copy1 = numbers3.slice()
// const deleted1 = copy1.splice(3, 0, 4, 5)
// console.log(copy1)
// console.log(deleted1)  /////  [] -Порожній масив

//                                                            Заміна
// Заміна - це операція додавання, в якій видаляються елементи в місці додавання нових. Для цього необхідно передати мінімум три аргументи.
//  Кількість елементів, що видаляються і додаються, може не збігатися.

// splice(position, num, new_element_1, new_element_2, ...)

// position - вказує на позицію (індекс) першого елемента для видалення
// num - визначає кількість елементів, що видаляються
// Третій, четвертий і всі наступні аргументи - це нові елементи, які додаються в масив.
// Наприклад, у нас є масив мов програмування з чотирьох елементів.

// const languages = ["C", "C++", "Java", "JavaScript"];

// // Заміняємо елемент з індексом 1 на новий
// languages.splice(1, 1, "Python");
// console.log(languages); // ["C", "Python", "Java", "JavaScript"]

// // Заміняємо один елемент (з індексом 2) на декілька
// languages.splice(2, 1, "C#", "Swift", "Go");
// console.log(languages); // ["C", "Python", "C#", "Swift", "Go", "JavaScript"]

// На зображенні показаний виклик методу languages.splice(1, 1, 'Python') з прикладу.

// splice replace
// Метод concat()
// Об'єднує два або більше масивів в один. Він не змінює масив, на якому викликається, а повертає новий. Порядок аргументів методу впливає на порядок елементів нового масиву.

// const oldClients = ["Mango", "Ajax", "Poly", "Kiwi"];
// const newClients = ["Monkong", "Singu"];

// const allClientsWithOldFirst = oldClients.concat(newClients);
// console.log(allClientsWithOldFirst); // ["Mango", "Ajax", "Poly", "Kiwi", "Monkong", "Singu"]

// const allClientsWithNewFirst = newClients.concat(oldClients);
// console.log(allClientsWithNewFirst); // ["Monkong", "Singu", "Mango", "Ajax", "Poly", "Kiwi"]

// console.log(oldClients); // ["Mango", "Ajax", "Poly", "Kiwi"]
// console.log(newClients); // ["Monkong", "Singu"]


// const numbers4 = [1, 2, 3, 4, 4, 4, 7]
// const copy2 = numbers4.slice()
// const deleted2 = copy2.splice(4, 2, 5, 6)
// console.log(copy2) //[1, 2, 3, 4, 5, 6, 7]
// console.log(deleted2) //[4,4]





// =======================================Функції
// Функція - це підпрограма, незалежна частина коду, призначена для багаторазового виконання конкретної задачі з різними початковими значеннями.
//  Функції дозволяють структурувати великі програми, зменшують повторення та ізолюють код.

// Функцію можна уявити у вигляді чорного ящика: вона отримує щось на вході (дані), і повертає щось на виході (результат виконання коду всередині неї).

// ==================================Оголошення функції
// // 1. Оголошення функції multiply
// function multiply() {
//   // Тіло функції
//   console.log("Це лог на момент виклику функції multiply");
// }

// // 2. Виклики функції multiply
// multiply(); // 'Це лог на момент виклику функції multiply'
// multiply(); // 'Це лог на момент виклику функції multiply'
// multiply(); // 'Це лог на момент виклику функції multiply'

// Оголошення функції (function declaration) починається з ключового слова function,
//  після якого стоїть ім'я - дієслово, що відповідає на запитання «Що зробити?» і пара круглих дужок.

// Тіло функції береться у фігурні дужки {} і містить інструкції, які необхідно виконати на момент її виклику.
//  Потім, коли необхідно, функція викликається за допомогою імені і пари круглих дужок.

//=================================== Параметри та аргументи
// В круглих дужках після імені функції зазначаються параметри - перелік даних, які функція очікує на момент виклику.

// Оголошення параметрів x, y, z
// function multiply(x, y, z) {
//   console.log(`Результат множення дорівнює ${x * y * z}`);
// }

// Параметри - це локальні змінні, доступні тільки у тілі функції. Вони розділяються комами. Параметрів може бути декілька, або взагалі не бути, у такому випадку записуються просто порожні круглі дужки.

// ЦІКАВО
// Параметри будуть створюватися кожного разу під час виконання функції, і їх окремі інкарнації жодним чином один з одним не пов'язані.

// На момент виклику функції, в круглих дужках можна передати аргументи - значення для оголошених параметрів функції.

// 1. Оголошення параметрів x, y, z
// function multiply(x, y, z) {
//   console.log(`Результат множення дорівнює ${x * y * z}`);
// }

// 2. Передача аргументів
// multiply(2, 3, 5); // Результат множення дорівнює 30
// multiply(4, 8, 12); // Результат множення дорівнює 384
// multiply(17, 6, 25); // Результат множення дорівнює 2550

// ЦІКАВО
// Порядок передачі аргументів повинен відповідати порядку оголошених параметрів:
//  значення першого аргументу буде присвоєно першому параметру, другого аргументу - другому параметру тощо. Якщо параметрів буде більше,
//   ніж аргументів, то параметрам без значень буде присвоєно undefined.

// function isIncluded(array, number) {
//     const result = array.includes(number)
//     console.log(result)
// }

// isIncluded([1, 2, 5, 8, 3], 4) // false
// isIncluded([1, 2, 5, 8, 3], 5) // true
// isIncluded(5, [1, 3, 5]) // error

//================================== Повернення значення
// Оператор return використовується для передачі значення з тіла функції у зовнішній код.
//  Коли інтерпретатор зустрічає return, він відразу ж виходить з функції (припиняє її виконання),
//  і повертає вказане значення у те місце коду, де була викликана функція.

// function multiply(x, y, z) {
//   console.log("Код до return виконується звичайним чином");

  // Повертаємо результат виразу множення
//   return x * y * z;

//   console.log("Цей лог ніколи не виконається, він стоїть після return");
// }

// Результат роботи функції можна зберегти у змінну
// let result = multiply(2, 3, 5);
// console.log(result); // 30

// result = multiply(4, 8, 12);
// console.log(result); // 384

// result = multiply(17, 6, 25);
// console.log(result); // 2550

// ЦІКАВО
// Оператор return без явно вказаного значення повертає спеціальне значення undefined. За відсутності return в тілі функції, вона все одно поверне undefined.

// function isIncluded(array, number) {
//     const result = array.includes(number)
//     // console.log(result) //службова тимчасова функція
//     return result
//     // console.log(result) //нiколи не спрацює
// }

// isIncluded([1, 2, 5, 8, 3], 4) // false

// const a = isIncluded([1, 2, 5, 8, 3], 4)
// console.log(a)

// console.log(isIncluded([1, 2, 5, 8, 3], 4)) // false
// console.log(isIncluded([1, 2, 5, 8, 3], 5)) // true

// const a = isIncluded([1, 2, 5, 8, 3], 4)
// console.log(a) // false
// const b = isIncluded([1, 2, 5, 8, 3], 5)
// console.log(b) // true

// Порядок виконання коду
// Коли інтерпретатор зустрічає виклик функції (або методу), він призупиняє виконання поточного коду і починає виконувати код з тіла функції. Після того як увесь код функції буде виконаний, інтерпретатор виходить з тіла функції, повертаючись у те місце, звідки прийшов, і продовжує виконувати код, наступний після виклику функції.

// function multiply(x, y, z) {
//   console.log(`Результат множення дорівнює ${x * y * z}`);
// }

// console.log("Лог до виклику функції multiply");
// multiply(2, 3, 5); // Результат множення дорівнює 30
// console.log("Лог після виклику функції multiply");

// Послідовність логів в консолі
// "Лог до виклику функції multiply"
// "Результат множення дорівнює 30"
// "Лог після виклику функції multiply"

// function add(a, b) {
// //   const sum = a + b
// //   return sum
// або
//   return a + b;
// }
// const number1 = add(1, 3); // 4
// console.log(number1)
// const number2 = add(5, 7); // 12
// console.log(number2)

// const sum = number1 + number2 // 16
// console.log(sum)

// const sum = add(1, 3) + add(5, 7)
// console.log(sum) // 16

// function add(a, b) {
//     if (typeof a !== 'number' || typeof b !== 'number') {
//         // // console.log('One of operands is not a number')
//         // return
//         return 'One of operands is not a number'
//     }
//     return a + b
// }

// console.log(add(3, 7)) // 10
// console.log(add( 5, '10')) // 'One of operands is not a number'
// console.log(add(3, '7')) //undefind


//======================================Параметри за замовчуванням
//Іноді необхідно оголосити функцію, у параметрів якої будуть значення, відмінні від undefined, навіть якщо для них не передали аргументи. Це робиться дуже простим та очевидним чином - достатньо вказати значення за замовчуванням безпосередньо на момент оголошення параметрів у підписі функції. У випадку такого запису, якщо для параметра не було передано значення аргументу, використовується значення за замовчуванням.

// function count(countFrom = 0, countTo = 10, step = 1) {
//   console.log(`countFrom = ${countFrom}, countTo = ${countTo}, step = ${step}`);

//   for (let i = countFrom; i <= countTo; i += step) {
//     console.log(i);
//   }
// }

// count(1, 5); // countFrom = 1, countTo = 5, step = 1
// count(2); // countFrom = 2, countTo = 10, step = 1
// count(); // countFrom = 0, countTo = 10, step = 1

// function add(a = 0, b = 0) {
//   // const sum = a + b
//   // return sum
//  console.log(a)
//  console.log(b)
//  return a + b;
// }

// console.log(add(1))


// function add(a , b , c ) {
//     console.log(a + b + c)
// }

// const num1 = 3;
// const num2 = 4

// add(num1, num2) //7
// add(3) 
// add()

// ====================================Псевдомасив arguments
// Доступ до списку всіх аргументів можна отримати за допомогою спеціальної змінної arguments, яка доступна тільки всередині функції і зберігає всі аргументи у якості псевдомасиву.

// Псевдомасив - колекція з властивістю length і можливістю звернутися до елементу за індексом, але відсутністю більшості методів для роботи з масивом.

// Розглянемо приклад використання arguments у функції, яка множить будь-яку кількість аргументів:

// function multiply() {
//   let total = 1;

//   for (const argument of arguments) {
//     total *= argument;
//   }

//   return total;
// }

// console.log(multiply(1, 2, 3)); //  6
// console.log(multiply(1, 2, 3, 4)); //  24
// console.log(multiply(1, 2, 3, 4, 5)); //  120

// function add() {
//     console.log(arguments)
//     console.log(arguments[0])
//     console.log(arguments.length)
//     let sum = 0;
//     for(const arg of arguments) {
//         console.log(arg)
//         sum +=arg
//     }
//     console.log(sum)
//     return sum
// }

// add(5, 7, 4, 9, 10)
// add(5, 7, 4, 9, 10, 100, 45, 36)

//==================================== Перетворення псевдомасиву
// Зазвичай псевдомасив необхідно перетворити у повноцінний масив, оскільки у псевдомасиву відсутні методи масиву, наприклад slice() або includes(). На практиці застосовують декілька основних способів.

// Використовуючи метод Array.from(), який створить масив із псевдомасиву.

// function fn() {
//   // Змінна args буде містити повноцінний масив
//   const args = Array.from(arguments);
// }


// function isIncluded() {
//     console.log(arguments)
//     const array = Array.from(arguments);
//     console.log(array)
//     const number = arguments[arguments.length - 1]
//     console.log(number)
//     const array2 = array.slice(0, -1)
//     console.log(array2)
//     console.log(array2.includes(number))
//     return array2.includes(number)
// }


// Використовуючи операцію ... (rest), вона дозволяє зібрати будь-яку кількість елементів, у нашому випадку аргументів, в масив, і зберегти його в змінну. Збираємо всі аргументи, використовуючи операцію rest безпосередньо в підписі функції.

// function fn(...args) {
//   // Змінна args буде містити повноцінний масив
// }

// ЦІКАВО
// Операція rest детальніше розглядається далі на курсі, тут показаний один з її можливих варіантів застосування.


// function isIncluded(...array) {
//     console.log(array)
//     const number = array[array.length - 1]
//     console.log(number)
//     const array2 = array.slice(0, -1)
//     console.log(array2)
//     console.log(array2.includes(number))
//     return array2.includes(number)
// }

// isIncluded(2, 5, 6, 8, 4, 9, 3, 7)


//============================= Патерн «Раннє повернення»
// Оператор if...else - це основний спосіб створення розгалужень. Проте, складні вкладені розгалуження роблять код заплутаним для розуміння.

// Створимо функцію, яка обробляє зняття коштів з особистого рахунку в банку. Вона отримує суму для зняття і поточний баланс рахунку, після чого, залежно від умови, виконує необхідний блок коду.

// function withdraw(amount, balance) {
//   if (amount === 0) {
//     console.log("Для проведення операції введіть суму більшу за нуль");
//   } else if (amount > balance) {
//     console.log("Недостатньо коштів на рахунку");
//   } else {
//     console.log("Операція зняття коштів проведена успішно");
//   }
// }

// withdraw(0, 300); // "Для проведення операції введіть суму більшу за нуль"
// withdraw(500, 300); // "Недостатньо коштів на рахунку"
// withdraw(100, 300); // "Операція зняття коштів проведена успішно"

// Навіть у такому простому прикладі є група вкладених умовних операторів, серед яких не одразу можна зрозуміти логіку виконання коду.

// У функції може бути більше одного оператора return. Головне пам'ятати, що виконання функції переривається, коли інтерпретатор зустрічає повернення, і увесь код після нього буде проігнорований в поточному виконанні функції.

// Патерн «Раннє повернення» - це спосіб використовувати можливість дострокового повернення з функції за допомогою оператора return. Використовуючи цей прийом, ми отримуємо чистіший, плоскіший і зрозуміліший код, який простіше рефакторити.

// Виділимо всі перевірки умов в окремі оператори if, після чого додамо код, що знаходиться в тілі else. В ідеальному випадку, повинен вийти плоский список умовних операторів, що йдуть один за одним, а в кінці - блок, який виконається тільки у тому випадку, якщо не виконається жоден if.

// function withdraw(amount, balance) {
//   // Якщо умова виконується, викликається console.log
//   // і вихід із функції. Код після тіла if не виконається.
//   if (amount === 0) {
//     console.log("Для проведення операції введіть суму більшу за нуль");
//     return;
//   }

//   // Якщо умова першого if не виконалась, його тіло пропускається
//   // та інтерпретатор доходе до другого if.
//   // Якщо умова виконується, викликається console.log і вихід із функції.
//   // Код, що знаходиться після тіла if, не виконається.
//   if (amount > balance) {
//     console.log("Недостатньо коштів на рахунку");
//     return;
//   }

//   // Якщо жоден із попередніх if не виконався,
//   // інтерпретатор доходить до цього коду і виконує його.
//   console.log("Операція зняття коштів проведена");
// }

// withdraw(0, 300); // "Для проведення операції введіть суму більшу за нуль"
// withdraw(500, 300); // "Недостатньо коштів на рахунку"
// withdraw(100, 300); // "Операція зняття коштів проведена"